C51 COMPILER V9.59.0.0   HD7279                                                            11/29/2018 22:59:14 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE HD7279
OBJECT MODULE PLACED IN .\Objects\HD7279.obj
COMPILER INVOKED BY: E:\Keil5\C51\BIN\C51.EXE USERS\HardWare\HD7279.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\USERS\Hard
                    -Ware;.\USERS) DEBUG OBJECTEXTEND PRINT(.\Listings\HD7279.lst) TABS(2) OBJECT(.\Objects\HD7279.obj)

line level    source

   1          /****************************HD7279.c***********************/
   2          #include "HD7279.h"
   3          #include "delay.h"
   4          #include "stdio.h"
   5          
   6          //HD7279显示内容对应数码
   7          unsigned char xdata realCode[] = \
   8            {0x7e , 0x30 , 0x6d , 0x79 , 0x33 , 0x5b , 0x5f , 0x70 , 0x7f , 0x7b , 0x01 , 0x80 , 0x00 , 0x6f};
   9          //  0      1       2      3      4      5      6      7      8      9      -    .     blank   error
  10          
  11          /**
  12            * @brief  HD7279发送一个字节
  13            * @note
  14            * @param  sendData：要发送的数据
  15            * @param
  16            * @retval none
  17            */
  18          void HD7279SendByte(unsigned char sendData)
  19          {
  20   1      #define SEND_DATA_LENGTH (8)
  21   1        unsigned char xdata sendCounter = 0;
  22   1        //片选端拉低
  23   1        cs=0;
  24   1        Delay10Us(12);
  25   1        //生成时钟信号并将八位数字依次发送
  26   1        for(sendCounter = 0 ; sendCounter < SEND_DATA_LENGTH ; sendCounter++)
  27   1        {
  28   2          if(sendData & 0x80)
  29   2          {
  30   3            dat = 1;
  31   3          }
  32   2          else
  33   2          {
  34   3            dat = 0;
  35   3          }
  36   2          //产生一个上升沿
  37   2          clk = 1;
  38   2          Delay10Us(2);
  39   2          //产生一个下降沿
  40   2          clk = 0;
  41   2          Delay10Us(2);
  42   2          sendData<<=1;
  43   2        }
  44   1        dat = 0;
  45   1      }
  46          
  47          /**
  48            * @brief  HD7279接收数据
  49            * @note
  50            * @param none
  51            *     @arg
  52            * @param none
  53            * @retval ：接受到的一个字节数据
  54            */
C51 COMPILER V9.59.0.0   HD7279                                                            11/29/2018 22:59:14 PAGE 2   

  55          unsigned char HD7279ReceiveByte(void)
  56          {
  57   1      #define RECEIVE_DATA_LENGTH (8)
  58   1        unsigned char xdata receiveCounter  = 0;
  59   1        unsigned char xdata receiveData = 0;
  60   1        //数据端拉高准备接收数据
  61   1        dat = 1;
  62   1        Delay10Us(12);
  63   1        //生成时钟信号并将八位数字一次接收
  64   1        for(receiveCounter = 0 ; receiveCounter < RECEIVE_DATA_LENGTH ; receiveCounter++)
  65   1        {
  66   2          //产生一个上升沿
  67   2          clk = 1;
  68   2          Delay10Us(2);
  69   2          receiveData*=2;
  70   2          if(dat)
  71   2          {
  72   3            receiveData|=0x01;
  73   3          }
  74   2          else
  75   2          {
  76   3          
  77   3          }
  78   2          clk = 0;
  79   2          Delay10Us(2);
  80   2        }
  81   1        dat = 0;
  82   1        return receiveData;
  83   1      }
  84          
  85          //通过HD7279让数码管显示对应内容
  86          /**
  87            * @brief  数码管显示函数
  88            * @note
  89            * @param cmd：命令字
  90            *     @arg
  91          * @param dataSend:数据字
  92            * @retval
  93            */
  94          void HD7279Write(unsigned char cmd , unsigned char dataSend)
  95          {
  96   1        HD7279SendByte(cmd);
  97   1        
  98   1        HD7279SendByte(dataSend); 
  99   1      }
 100          #define DIGITTAL_TUBE_LENGTH  8  
 101          /** 
 102            * @brief  HD7279  
 103            * @param  showValue HD7279需要显示的整型数据 
 104            * @retval none
 105            */
 106          void HD7279ShowInt(int showValue)
 107          {
 108   1        uint8_t xdata i=0;
 109   1        /*通过Springf存储的字符数组*/
 110   1        uint8_t xdata myString[DIGITTAL_TUBE_LENGTH]={0};
 111   1        /*通过数码管显示字符数组*/
 112   1        uint8_t xdata tubeString[DIGITTAL_TUBE_LENGTH]={0};
 113   1        /*显示有效位计数*/
 114   1        uint8_t xdata dataLength =0;
 115   1        /*判断是否在显示范围内，将其转换为字符数串*/
 116   1        if(showValue>=-9999999&&showValue<=99999999)
C51 COMPILER V9.59.0.0   HD7279                                                            11/29/2018 22:59:14 PAGE 3   

 117   1        {
 118   2          /*将输入数组转化为字符串*/
 119   2          sprintf(myString,"%d",showValue);
 120   2        }
 121   1        else
 122   1        {
 123   2          showValue = 0;
 124   2          /*超出最大显示值*/
 125   2          for(i=0;i<DIGITTAL_TUBE_LENGTH;i++)
 126   2          {
 127   3            HD7279Write(UNDECODE+i,0x01);
 128   3          }
 129   2          return;
 130   2        }
 131   1        /*计算长度*/
 132   1        for(i=0;i<DIGITTAL_TUBE_LENGTH;i++)
 133   1        {
 134   2          /*有效位计数*/
 135   2          if(myString[i]!=0x00)
 136   2          {
 137   3            dataLength++;
 138   3          }
 139   2        }
 140   1        for(i=0;i<dataLength;i++)
 141   1        {
 142   2          /*如果是“-”便不管*/
 143   2          if(myString[i]=='-')
 144   2          {
 145   3            myString[i]=0x01;
 146   3          }
 147   2          else
 148   2          {
 149   3            /*ASCII码 0x30 进行赋值   由于将数据转换为字符型数据 由ASCII码表可得0-9的数字
             -的ASCII码减去0x30可得相对应的数字0-9
 150   3            填入HD7279显示内容对应数码数组realCode*/
 151   3            myString[i]=realCode[(myString[i]-0x30)];
 152   3            tubeString[(DIGITTAL_TUBE_LENGTH - dataLength) + i]=myString[i];
 153   3          }
 154   2        }
 155   1        
 156   1        for(i=0;i<DIGITTAL_TUBE_LENGTH;i++)
 157   1        {
 158   2          HD7279Write(UNDECODE+DIGITTAL_TUBE_LENGTH -1 - i,tubeString[i]);
 159   2        }
 160   1      
 161   1      
 162   1      }
 163          /*通过数据提取*/
 164          void HD7279ShowFloat(uint8_t showAfterSmall,double showValue)
 165          {
 166   1        uint8_t xdata index=0;
 167   1        /*通过个人译码*/
 168   1        uint8_t xdata myCode[DIGITTAL_TUBE_LENGTH]={0};
 169   1        /*通过数码管显示字符数组*/
 170   1        uint8_t xdata tubeString[DIGITTAL_TUBE_LENGTH]={0};
 171   1        /*判断是否在显示范围内，将其转换为字符数串*/
 172   1        int xdata showValueInt = (int)showValue*showAfterSmall*10;
 173   1        uint8_t xdata pointIndex = DIGITTAL_TUBE_LENGTH - showAfterSmall - 1;
 174   1        int xdata getNum=DIGITTAL_TUBE_LENGTH *10;
 175   1        uint8_t xdata dataLength=0;
 176   1        
 177   1        if(showValue>-(7-showAfterSmall)*10&&showValue<(8-showAfterSmall)*10)
C51 COMPILER V9.59.0.0   HD7279                                                            11/29/2018 22:59:14 PAGE 4   

 178   1        {
 179   2          if(showValue<0)
 180   2          {
 181   3            myCode[index]=10;
 182   3            showValue = fabs(showValueInt);
 183   3            index++;
 184   3            dataLength++;
 185   3          }
 186   2          
 187   2          for(;index<DIGITTAL_TUBE_LENGTH;index++)
 188   2          {
 189   3            if((showValueInt/getNum)!=0)
 190   3            {
 191   4              myCode[index]=showValueInt/getNum;
 192   4              showValueInt   = showValueInt % getNum;
 193   4              dataLength++;
 194   4            }
 195   3            getNum=getNum/10;
 196   3          }
 197   2          
 198   2          for(index=0;index<dataLength;index++)
 199   2          {
 200   3            tubeString[index]=realCode[myCode[index]];
 201   3            dataLength++;
 202   3          }
 203   2          
 204   2        }
 205   1        else
 206   1        {
 207   2          showValue = 0;
 208   2          /*超出最大显示值*/
 209   2          for(index=0;index<DIGITTAL_TUBE_LENGTH;index++)
 210   2          {
 211   3            HD7279Write(UNDECODE+index,0x01);
 212   3          }
 213   2          return;
 214   2        }
 215   1        
 216   1        HD7279Write(UNDECODE + showAfterSmall + 1,tubeString[index]);
 217   1        
 218   1        for(index=0;index<DIGITTAL_TUBE_LENGTH;index++)
 219   1        {
 220   2          HD7279Write(UNDECODE+DIGITTAL_TUBE_LENGTH -1 - index,tubeString[index]);
 221   2        }
 222   1      
 223   1      
 224   1      
 225   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1147    ----
   CONSTANT SIZE    =     35    ----
   XDATA SIZE       =     14      53
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
